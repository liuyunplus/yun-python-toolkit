---
title: '打造正则引擎[1]--正则表达式的介绍'
date: 2020-06-07 10:46:40
categories: 正则表达式
mathjax: true
---
在计算机领域，正则表达式是一个名副其实的神器，它的诞生可以说是直接推动了计算机软件的发展进程。到目前为止它已经在编译器，搜索引擎，文本处理等多个领域中有着广泛的应用，并且仍在持续的探索着许多未知的可能性。<!-- more -->对于普通使用者而言，熟练的掌握好正则表达式能够有效的提高我们的工作效率，改善我们的生活品质。可是面对形如天书般的正则语法，不少人对此望而却步。本文将从正则表达式原理出发，让读者能够对正则表达式语法产生直观的印象，后续我们通过亲自动手打造一个正则引擎，来加深对正则表达式的理解。

#### 1 什么是语言？

我们平时说的语言是由一个个句子所构成的，其中的每个句子都是由字符组成的排列组合。对于英文来说，这些字符来自字母表，而对于中文来说，这些字符则取自汉字表。无论是字母表还是汉字表，它们都是有限的字符集合，基于这些字符集合，构成了纷繁多样的语言世界。我们可以进一步的进行抽象概括，语言就是某个给定字母表上一个任意的可数的字符串集合，其中给定的字母表是一个有限的符号集合，而字符串是该字母表中符号的一个有穷序列。例如，计算机指令是由{0, 1}这样的二进制字母表所组成的有穷序列，而计算机语言就是由这些计算机指令所构成的集合。基于这种抽象，我们可以针对语言做一些代数运算。在此之前，我们先来看一下字符串的运算。

假设 x 和 y 都是字符串，x 和 y 的连接操作就是把 y 附加到 x 后面所形成的串。例如，如果 x = dog 且 y = house，那么 xy = doghouse。假设 $\epsilon$ 是空串，那么对于任何字符串 $s$ 都有，$s{\epsilon} = {\epsilon}{s}=s$。如果把两个串的连接看成是这两个串的"乘积"，我们可以定义串的"指数"运算如下：定义 $s^0$ 为 $\epsilon$ ，并且对于 $i\gt0$，$s^i$ 为 $s^{i-1}s$。因为 $\epsilon{s}=s$，由此可知 $s^1=s$，$s^2=ss$，$s^3=sss$，依次类推。

语言运算除了常见的集合运算，还有连接运算和闭包运算，语言的连接就是从第一个语言中任取一个串，再从第二个语言中任取一个串，然后将它们连接后得到的所有串的集合。语言的闭包运算包括Kleene闭包和正闭包，一个语言 $L$ 的Kleene闭包记作 $L^*$，就是将 $L$ 连接0次或多次后得到的串集；$L$ 的正闭包记作 $L^+$，就是将 $L$ 连接1次或多次后得到的串集。下表列出了这些运算的正式定义。

| 运算          | 定义和表示 |
| ------------- | ---------- |
| L和M的并      | $L\cup M= \lbrace s\mid s属于L或者属于M \rbrace $ |
| L和M的连接    | $ LM = \lbrace st\mid s属于L且t属于M \rbrace $ |
| L的Kleene闭包 | $ L^* = \cup_{i=0}^{\infty} L^i $ |
| L的正闭包     | $ L^+ = \cup_{i=1}^{\infty} L^i $ |

令 $L$ 表示字母的集合{A, B, ..., Z, a, b, c, ..., z}，令 $D$ 表示数字的集合{0, 1, ..., 9}。根据如上所述的运算，我们可以构造得到新的语言。

1）$L\cup{D}$ 是长度为1的串的集合，每个串是一个字母或一个数字。

2）$LD$ 是长度为2的串的集合，每个串都是一个字母跟一个数字。

3）$L^4$ 是所有由4个字母构成的串的集合。

4）$L^*$ 是所有由字母构成的串的集合，包括空串 $\epsilon$。

5）$L(L\cup{D})^*$ 是所有以字母开头的，由字母和数字组成的串的集合。

6）$D^+$ 是由一个或多个数字构成的串的集合。

#### 2 正则的介绍

为了更好的描述语言，人们通过使用正则表达式来表示语言，一个正则表达式就代表了一种类型的语言。通过上面的描述我们知道可以对语言进行代数运算来构造另一种语言。同理，可以对较小的正则表达式进行代数运算，从而得到一个更大的正则表达式。例如，假设 $r$ 和 $s$ 都是正则表达式，分别表示语言 $L(r)$ 和 $L(s)$，通过对其进行简单的并、连接和闭包运算，我们就能构造出一个更加丰富的正则表达式。

1）$(r)\mid(s)$ 是一个正则表达式，表示语言 $L(r)\cup{L(s)}$。

2）$(r)(s)$ 是一个正则表达式，表示语言 $L(r)L(s)$。

3）$(r)^*$ 是一个正则表达式，表示语言 $(L(r))^*$。

4）$(r)$是一个正则表达式，表示语言 $L(r)$。

同理，我们可以给这些运算符设置一些优先级，以便在书写时省去一些不必要的括号，完整的符号优先级列表如下所示，其中标红的是我们已经了解到的基本运算符，未标红的是一些扩展运算符，它们的存在主要是为了增强正则表达式的表述能力，后续我们会了解到它们的含义。

| 优先权 | 符号                       |
| ------ | -------------------------- |
| 最高   | \                                     |
| 高     | $\color{red}{()}$、(?:)、(?=)、[]      |
| 中     | $\color{red}*$、+、？、{n}、{n,}、{n,m} |
| 低     | ^、\$、一般字符                         |
| 次最低 | $\color{red}{连接}$                    |
| 最低   | $\color{red}\mid $                    |

通过约定的运算符优先级，我们可以将表达式 $(a)\mid((b)^*(c))$ 改写为 $a\mid b^*{c}$。这两个表达式都描述的是同样的串集合，而后者看起来会简洁许多。和其他数学运算符一样，正则表达式同样也遵守一些代数定律，通过这些定律我们可以了解到不同形式的正则表达式可以是等价的，因此它们描述的语言也是相同的，下表列出了对于任意正则表达式 $r$，$s$ 和 $t$ 都成立的代数定律。

| 定律                          | 描述                      |
| ----------------------------- | ------------------------- |
| $r\mid s=s\mid r$             | $\mid$ 是可交换的         |
| $r\mid(s\mid t)=(r\mid s)t$   | $\mid$ 是可结合的         |
| $r(st)=(rs)t$                 | 连接是可结合的             |
| $r(s\mid t)=rs\mid rt;(s\mid t)r=sr\mid tr$ | 连接对 $\mid$ 是可分配的|
| $\epsilon{r}=r\epsilon=r$     | $\epsilon$ 是连接的单位元 |
| $r^*=(r\mid\epsilon)^*$       | 闭包中一定包含 $\epsilon$ |
| $r^\{**\}=r^\{*\}$      | * 具有幂等性              |

#### 3 正则的扩展

通过对子表达式进行基本的并、连接和闭包等运算我们就可以构造出许多表意丰富的正则表达式，可是要满足一些特殊的需求仍然远远不够。因此许多正则引擎为基本的正则表达式添加了一些扩展运算符，它们被用来增强正则表达式描述串模式的能力，如下所示：

| 表达式 | 说明                               | 示例      | 匹配内容              |
| ------ | ---------------------------------- | --------- | --------------------- |
| .      | 匹配除换行符以外的任意字符         | a.c       | abc, asg, a2c |
| ^      | 匹配一行的开始                     | ^abc      | abc，abcdef，abc123   |
| $      | 匹配一行的结尾                     | abc$      | myabc，123abc，theabc |
| ?      | ?前一个字符出现0次或1次            | ab?c      | ac，abc               |
| {n\}​   | {}前一个字符出现的次数等于n次      | (abc){2}  | abcabc                |
| {n,}​   | {}前一个字符出现的次数大于等于n次  | (abc){2,} | abcabc, abcabcabc     |
| {n,m}​  | {}前一个字符出现的次数为[n, m]之间 | (a){2,4}  | aa, aaa, aaaaa        |
| [...]​  | 匹配方括号内的任意字符             | [abc]     | a，b，c               |
| [^...] | 排除方括号内的所有字符             | [^abc]    | xyz, 123, 1de         |
| [a-z]  | 匹配a到z之间的任意字符             | [b-z]     | bc, mind, xyz         |

除了上面的扩展运算符，大部分正则实现还会提供一些常用的字符集简写，使用它们可以让我们的正则表达式更加的简练，例如，\d 等价于 [0-9]，\w 等价于 [a-zA-Z0-9_]，更多字符集简写可以查阅下表。

| 符号 | 描述                                       |
| ---- | ------------------------------------------ |
| \d   | 匹配数字，等同于[0-9]                      |
| \D   | 匹配非数字，等同于\[^\d]                   |
| \s   | 匹配所有空格字符，等同于[\t\n\f\r\p{Z}]    |
| \S   | 匹配所有非空格字符，等同于\[^\s]           |
| \w   | 匹配所有字母数字，等同于[a-zA-Z0-9_]       |
| \W   | 匹配所有非字母数字，即符号，等同于\[^\w]   |
| \f   | 匹配一个换页符                             |
| \n   | 匹配一个换行符                             |
| \r   | 匹配一个回车符                             |
| \t   | 匹配一个制表符                             |
| \v   | 匹配一个垂直制表符                         |
| \p   | 匹配CR/LF(等同于\r\n)，用来匹配DOS行终止符 |

#### 4 总结

本文我们从形式语言的理论出发，讲解了形式语言是如何对自然语言进行抽象的，并通过数学工具来进行描述，形式语言的表示方法可以有多种，例如形式文法，正则表达式和状态机等。了解了这一点我们可以知道一个正则表达式描述的就是一种类型的形式语言。通过对子表达式进行集合，连接和闭包运算可以构造出更大的正则表达式，这些都是正则表达式的基础运算符。现代正则引擎实现为了增强正则表达式的描述能力，大多都会添加一些扩展运算符和字符集简写，这些扩展使得正则表达式的书写更加简洁干练，同时也增加了正则语法的复杂度。但我们只要抓住核心，就是正则表达式是形式语言的一种表示方法，基于形式语言的集合，连接和闭包运算才是正则表达式的基础运算符，而其他的只是一些增强性的功能，了解这一点我们就能够对正则表达式运用的更加自如。